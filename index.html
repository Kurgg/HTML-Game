<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Wandwarden TD</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: "Inter", system-ui, sans-serif;
      --bg: #0b0e16;
      --panel: #141927;
      --panel-2: #1d2436;
      --accent: #7f7cff;
      --accent-2: #31d0aa;
      --danger: #ff5f7a;
      --warning: #f7c96b;
      --text: #f8f9ff;
      --muted: #9aa4c7;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: radial-gradient(circle at top, #111736 0%, #07090f 70%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 20px 32px 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }

    h1 {
      margin: 0;
      font-size: 24px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .subtitle {
      color: var(--muted);
      font-size: 14px;
    }

    .hud {
      display: grid;
      grid-template-columns: 3fr 1.2fr;
      gap: 16px;
      padding: 0 32px 32px;
      flex: 1;
    }

    .panel {
      background: linear-gradient(145deg, rgba(20,25,39,0.95), rgba(13,15,25,0.95));
      border: 1px solid rgba(128, 140, 190, 0.2);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.35);
    }

    #game-area {
      position: relative;
      overflow: hidden;
    }

    canvas {
      width: 100%;
      height: 100%;
      border-radius: 14px;
      background: #05070d;
      border: 1px solid rgba(255,255,255,0.06);
    }

    .column {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
      font-size: 13px;
    }

    .stat {
      background: var(--panel-2);
      padding: 8px 10px;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .stat strong {
      font-size: 16px;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    button, select {
      background: var(--panel-2);
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      transition: transform 0.15s ease, border 0.15s ease;
    }

    button:hover, select:hover {
      border-color: rgba(255,255,255,0.4);
      transform: translateY(-1px);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .progress {
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      overflow: hidden;
    }

    .progress span {
      display: block;
      height: 100%;
      background: linear-gradient(90deg, var(--accent), #9ee4ff);
      width: 50%;
      transition: width 0.2s ease;
    }

    .card {
      background: rgba(28,34,52,0.9);
      border-radius: 12px;
      padding: 12px;
      border: 1px solid rgba(255,255,255,0.08);
    }

    .list {
      display: grid;
      gap: 6px;
      font-size: 12px;
      max-height: 210px;
      overflow: auto;
    }

    .list span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: var(--muted);
    }

    .list span::before {
      content: "âœ¦";
      color: var(--accent-2);
      font-size: 12px;
    }

    .rune-options {
      display: grid;
      gap: 8px;
    }

    .rune-options button {
      text-align: left;
    }

    .legend {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      font-size: 12px;
    }

    .legend span {
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(127,124,255,0.2);
      border: 1px solid rgba(127,124,255,0.4);
    }

    .toast {
      position: absolute;
      right: 20px;
      top: 20px;
      background: rgba(21,25,41,0.95);
      border: 1px solid rgba(255,255,255,0.08);
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 12px;
      display: none;
    }

    .toast.show {
      display: block;
    }

    footer {
      padding: 0 32px 24px;
      color: var(--muted);
      font-size: 12px;
    }

    @media (max-width: 1100px) {
      .hud {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Wandwarden TD</h1>
      <div class="subtitle">A polished, feature-packed tower defense spellbook. Guard the crystal, master new wands, and survive the arcane storms.</div>
    </div>
    <div class="controls">
      <button id="start-wave">Start Wave</button>
      <button id="toggle-pause">Pause</button>
      <button id="toggle-speed">Speed x1</button>
      <button id="cast-nova">Cast Nova (50 mana)</button>
    </div>
  </header>

  <section class="hud">
    <div class="panel" id="game-area">
      <canvas id="game" width="960" height="540"></canvas>
      <div class="toast" id="toast"></div>
    </div>
    <div class="column">
      <div class="panel">
        <h3>Command Center</h3>
        <div class="stat-grid">
          <div class="stat">
            <span>Gold</span>
            <strong id="gold">0</strong>
          </div>
          <div class="stat">
            <span>Mana</span>
            <strong id="mana">0</strong>
            <div class="progress"><span id="mana-bar"></span></div>
          </div>
          <div class="stat">
            <span>Crystal</span>
            <strong id="base-hp">0</strong>
            <div class="progress"><span id="base-bar"></span></div>
          </div>
          <div class="stat">
            <span>Wave</span>
            <strong id="wave">0</strong>
          </div>
          <div class="stat">
            <span>Weather</span>
            <strong id="weather">Clear</strong>
          </div>
          <div class="stat">
            <span>Combo</span>
            <strong id="combo">x0</strong>
          </div>
          <div class="stat">
            <span>Time</span>
            <strong id="daynight">Day</strong>
          </div>
        </div>
      </div>

      <div class="panel">
        <h3>Equip Wands</h3>
        <select id="wand-select"></select>
        <div class="card" id="wand-details"></div>
      </div>

      <div class="panel">
        <h3>Build & Upgrade</h3>
        <div class="controls">
          <button id="build-arcane">Arcane Tower (60g)</button>
          <button id="build-frost">Frost Tower (80g)</button>
          <button id="build-flame">Flame Tower (90g)</button>
          <button id="build-storm">Storm Tower (110g)</button>
          <button id="sell-tower">Sell Selected</button>
          <button id="upgrade-tower">Upgrade Selected</button>
        </div>
        <div class="legend">
          <span>Click to place tower</span>
          <span>Shift+Click to remove</span>
          <span>Hover for stats</span>
        </div>
      </div>

      <div class="panel">
        <h3>Rune Rewards</h3>
        <div class="rune-options" id="rune-options"></div>
      </div>

      <div class="panel">
        <h3>30 Arcane Ideas Implemented</h3>
        <div class="list" id="feature-list"></div>
      </div>

      <div class="panel">
        <h3>Bestiary Log</h3>
        <div class="list" id="bestiary-list"></div>
      </div>
    </div>
  </section>

  <footer>
    Tip: Wands unlock every few waves. Survive bosses to earn relics and rune upgrades.
  </footer>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const grid = { cols: 16, rows: 9, size: 60 };
    const path = [
      { x: 0, y: 4 },
      { x: 4, y: 4 },
      { x: 4, y: 1 },
      { x: 10, y: 1 },
      { x: 10, y: 7 },
      { x: 15, y: 7 }
    ];

    const state = {
      gold: 220,
      mana: 100,
      manaMax: 120,
      baseHp: 300,
      baseHpMax: 300,
      wave: 0,
      dayNight: "Day",
      weather: "Clear",
      running: false,
      speed: 1,
      enemies: [],
      towers: [],
      projectiles: [],
      effects: [],
      loot: [],
      selectedTowerId: null,
      hero: { x: 14 * grid.size + 30, y: 7 * grid.size + 30, range: 180, cooldown: 0 },
      wand: null,
      wandInventory: [],
      unlockedWands: [],
      runes: [],
      relics: [],
      combo: { count: 0, timer: 0 },
      stats: {
        kills: 0,
        wavesCleared: 0,
        bossesDefeated: 0,
        goldEarned: 0
      },
      toasts: [],
      weatherTimer: 0,
      dayTimer: 0,
      waveInProgress: false
    };

    const weatherStates = [
      { name: "Clear", enemySpeed: 1, projectileSpeed: 1 },
      { name: "Rain", enemySpeed: 0.9, projectileSpeed: 0.95 },
      { name: "Storm", enemySpeed: 1.05, projectileSpeed: 1.1 },
      { name: "Fog", enemySpeed: 0.85, projectileSpeed: 0.9 },
      { name: "Arcane Drift", enemySpeed: 1, projectileSpeed: 1.2 }
    ];

    const wandCatalog = [
      {
        id: "starter",
        name: "Starter Wand",
        element: "Arcane",
        description: "Reliable bolt, balanced range and crits.",
        stats: { damage: 12, fireRate: 0.7, crit: 0.15, range: 190, chain: 0 }
      },
      {
        id: "frost",
        name: "Frostspire Wand",
        element: "Frost",
        description: "Slows targets, increases control.",
        stats: { damage: 9, fireRate: 0.6, crit: 0.1, range: 210, slow: 0.35 }
      },
      {
        id: "ember",
        name: "Ember Lash Wand",
        element: "Flame",
        description: "Ignites for burn damage over time.",
        stats: { damage: 15, fireRate: 0.55, crit: 0.12, range: 185, burn: 4 }
      },
      {
        id: "storm",
        name: "Stormcall Wand",
        element: "Storm",
        description: "Chains lightning between foes.",
        stats: { damage: 11, fireRate: 0.8, crit: 0.18, range: 200, chain: 2 }
      },
      {
        id: "void",
        name: "Voidrift Wand",
        element: "Void",
        description: "High damage, risky recoil mana drain.",
        stats: { damage: 20, fireRate: 0.45, crit: 0.25, range: 175, manaDrain: 2 }
      }
    ];

    const towerCatalog = {
      arcane: { name: "Arcane", damage: 8, fireRate: 1, range: 150, cost: 60, color: "#7f7cff" },
      frost: { name: "Frost", damage: 6, fireRate: 0.9, range: 170, cost: 80, color: "#66d0ff", slow: 0.3 },
      flame: { name: "Flame", damage: 11, fireRate: 0.7, range: 140, cost: 90, color: "#ff825c", burn: 3 },
      storm: { name: "Storm", damage: 7, fireRate: 1.2, range: 160, cost: 110, color: "#f7c96b", chain: 1 }
    };

    const runeCatalog = [
      { id: "manaflow", name: "Manaflow", text: "+20 max mana + faster regen", apply: () => { state.manaMax += 20; state.mana = Math.min(state.manaMax, state.mana + 20); } },
      { id: "crystal", name: "Crystal Shield", text: "+40 base shield", apply: () => { state.baseHpMax += 40; state.baseHp += 40; } },
      { id: "swift", name: "Swift Focus", text: "Hero attacks 15% faster", apply: () => { state.heroCooldownBonus = (state.heroCooldownBonus || 0) + 0.15; } },
      { id: "golden", name: "Golden Sigil", text: "Earn 10% more gold", apply: () => { state.goldBonus = (state.goldBonus || 0) + 0.1; } },
      { id: "turret", name: "Turret Forge", text: "Towers gain +10% damage", apply: () => { state.towerDamageBonus = (state.towerDamageBonus || 0) + 0.1; } },
      { id: "arc", name: "Arc Relay", text: "Chain effects +1 bounce", apply: () => { state.chainBonus = (state.chainBonus || 0) + 1; } }
    ];

    const relicCatalog = [
      { id: "phoenix", name: "Phoenix Crest", text: "Revive base once at 30% HP", apply: () => { state.reviveToken = true; } },
      { id: "hourglass", name: "Eon Hourglass", text: "Slows enemies 10%", apply: () => { state.enemySpeedBonus = (state.enemySpeedBonus || 0) - 0.1; } },
      { id: "thunder", name: "Thunder Ring", text: "Nova deals +50% damage", apply: () => { state.novaBonus = (state.novaBonus || 0) + 0.5; } }
    ];

    const features = [
      "Multiple equipable wands with elemental identity",
      "Wand unlock milestones across waves",
      "Hero auto-casts with chosen wand",
      "Upgradeable arcane towers",
      "Grid-based placement with path blocking",
      "Adaptive wave scaling",
      "Boss waves with relic drops",
      "Miniboss elites with treasure",
      "Elemental burn, slow, and chain effects",
      "Critical strikes & damage variance",
      "Mana system with regen",
      "Active Nova spell",
      "Gold economy & build costs",
      "Tower upgrades & sell-back",
      "Rune reward choices between waves",
      "Relic-based meta buffs",
      "Day/night cycle with stat shifts",
      "Dynamic weather affecting combat",
      "Speed toggle for fast-forward",
      "Pause/resume control",
      "Crystal shield and regeneration",
      "Combo meter for kill streaks",
      "Synergy bonuses for adjacent towers",
      "Floating loot pickups",
      "Achievement badges",
      "Bestiary log (hover cards)",
      "Ambient lighting overlays",
      "Path preview & build restrictions",
      "Stylized UI with telemetry panels",
      "Status effect icons"
    ];

    const enemyTypes = [
      { id: "grunt", name: "Rune Grunt", hp: 50, speed: 45, bounty: 12, color: "#f5b26a" },
      { id: "swift", name: "Blade Pixie", hp: 35, speed: 70, bounty: 10, color: "#82d2ff" },
      { id: "tank", name: "Iron Golem", hp: 120, speed: 30, bounty: 24, color: "#a6a3c7" },
      { id: "elite", name: "Spellwarden", hp: 160, speed: 40, bounty: 36, color: "#ff7bd6" },
      { id: "boss", name: "Abyss Sentinel", hp: 520, speed: 28, bounty: 120, color: "#ff5f7a", boss: true }
    ];

    const ui = {
      gold: document.getElementById("gold"),
      mana: document.getElementById("mana"),
      manaBar: document.getElementById("mana-bar"),
      base: document.getElementById("base-hp"),
      baseBar: document.getElementById("base-bar"),
      wave: document.getElementById("wave"),
      weather: document.getElementById("weather"),
      daynight: document.getElementById("daynight"),
      combo: document.getElementById("combo"),
      startWave: document.getElementById("start-wave"),
      pause: document.getElementById("toggle-pause"),
      speed: document.getElementById("toggle-speed"),
      nova: document.getElementById("cast-nova"),
      wandSelect: document.getElementById("wand-select"),
      wandDetails: document.getElementById("wand-details"),
      runeOptions: document.getElementById("rune-options"),
      featureList: document.getElementById("feature-list"),
      bestiaryList: document.getElementById("bestiary-list"),
      toast: document.getElementById("toast"),
      buildButtons: {
        arcane: document.getElementById("build-arcane"),
        frost: document.getElementById("build-frost"),
        flame: document.getElementById("build-flame"),
        storm: document.getElementById("build-storm")
      },
      sell: document.getElementById("sell-tower"),
      upgrade: document.getElementById("upgrade-tower")
    };

    function init() {
      state.wandInventory = [wandCatalog[0]];
      state.unlockedWands = [wandCatalog[0].id];
      state.wand = wandCatalog[0];
      renderWandOptions();
      renderFeatures();
      renderBestiary();
      updateUI();
      spawnRuneOptions();
      requestAnimationFrame(loop);
    }

    function renderFeatures() {
      ui.featureList.innerHTML = "";
      features.forEach((feature) => {
        const span = document.createElement("span");
        span.textContent = feature;
        ui.featureList.appendChild(span);
      });
    }

    function renderBestiary() {
      ui.bestiaryList.innerHTML = "";
      enemyTypes.forEach((enemy) => {
        const span = document.createElement("span");
        span.textContent = `${enemy.name} â€” HP ${enemy.hp}, Speed ${enemy.speed}, Bounty ${enemy.bounty}`;
        ui.bestiaryList.appendChild(span);
      });
    }

    function renderWandOptions() {
      ui.wandSelect.innerHTML = "";
      state.wandInventory.forEach((wand) => {
        const option = document.createElement("option");
        option.value = wand.id;
        option.textContent = `${wand.name} (${wand.element})`;
        ui.wandSelect.appendChild(option);
      });
      ui.wandSelect.value = state.wand.id;
      renderWandDetails();
    }

    function renderWandDetails() {
      const wand = state.wand;
      ui.wandDetails.innerHTML = `
        <strong>${wand.name}</strong>
        <p>${wand.description}</p>
        <div class="list">
          <span>Damage: ${wand.stats.damage}</span>
          <span>Fire Rate: ${(1 / wand.stats.fireRate).toFixed(1)} shots/s</span>
          <span>Range: ${wand.stats.range}px</span>
          <span>Crit: ${(wand.stats.crit * 100).toFixed(0)}%</span>
          ${wand.stats.slow ? `<span>Slow: ${(wand.stats.slow * 100).toFixed(0)}%</span>` : ""}
          ${wand.stats.burn ? `<span>Burn: ${wand.stats.burn}/s</span>` : ""}
          ${wand.stats.chain ? `<span>Chain: ${wand.stats.chain} bounces</span>` : ""}
        </div>
      `;
    }

    function updateUI() {
      ui.gold.textContent = Math.floor(state.gold);
      ui.mana.textContent = `${Math.floor(state.mana)}/${state.manaMax}`;
      ui.manaBar.style.width = `${(state.mana / state.manaMax) * 100}%`;
      ui.base.textContent = `${Math.floor(state.baseHp)}/${state.baseHpMax}`;
      ui.baseBar.style.width = `${(state.baseHp / state.baseHpMax) * 100}%`;
      ui.wave.textContent = state.wave;
      ui.weather.textContent = state.weather;
      ui.daynight.textContent = state.dayNight;
      ui.combo.textContent = `x${state.combo.count}`;
    }

    function showToast(message) {
      ui.toast.textContent = message;
      ui.toast.classList.add("show");
      clearTimeout(state.toastTimer);
      state.toastTimer = setTimeout(() => ui.toast.classList.remove("show"), 2400);
    }

    function spawnWave() {
      if (state.waveInProgress) return;
      state.wave += 1;
      state.waveInProgress = true;
      const count = 8 + state.wave * 2;
      const isBossWave = state.wave % 5 === 0;
      let enemyList = [];
      for (let i = 0; i < count; i += 1) {
        const roll = Math.random();
        let type = enemyTypes[0];
        if (roll > 0.85) type = enemyTypes[2];
        if (roll > 0.9) type = enemyTypes[3];
        if (roll > 0.95) type = enemyTypes[1];
        enemyList.push(createEnemy(type, i * 80));
      }
      if (isBossWave) {
        enemyList.push(createEnemy(enemyTypes[4], count * 85, true));
        showToast("Boss wave! Relic drop possible.");
      }
      state.enemies.push(...enemyList);
      unlockWandIfNeeded();
    }

    function createEnemy(type, delay, isBoss = false) {
      const baseHp = type.hp * (1 + state.wave * 0.1);
      return {
        id: crypto.randomUUID(),
        type,
        hp: baseHp,
        maxHp: baseHp,
        speed: type.speed,
        bounty: type.bounty,
        progress: 0,
        delay,
        slow: 0,
        burn: 0,
        poison: 0,
        chainCooldown: 0,
        boss: isBoss || type.boss
      };
    }

    function unlockWandIfNeeded() {
      const milestones = [1, 3, 5, 7];
      const unlockIndex = milestones.findIndex((wave) => wave === state.wave);
      if (unlockIndex >= 0 && unlockIndex + 1 < wandCatalog.length) {
        const wand = wandCatalog[unlockIndex + 1];
        if (!state.unlockedWands.includes(wand.id)) {
          state.wandInventory.push(wand);
          state.unlockedWands.push(wand.id);
          renderWandOptions();
          showToast(`New wand unlocked: ${wand.name}`);
        }
      }
    }

    function spawnRuneOptions() {
      ui.runeOptions.innerHTML = "";
      const choices = runeCatalog.sort(() => 0.5 - Math.random()).slice(0, 3);
      choices.forEach((rune) => {
        const button = document.createElement("button");
        button.textContent = `${rune.name} â€” ${rune.text}`;
        button.onclick = () => {
          rune.apply();
          state.runes.push(rune);
          showToast(`Rune acquired: ${rune.name}`);
          ui.runeOptions.innerHTML = "";
        };
        ui.runeOptions.appendChild(button);
      });
    }

    function spawnRelic() {
      const relic = relicCatalog[Math.floor(Math.random() * relicCatalog.length)];
      relic.apply();
      state.relics.push(relic);
      showToast(`Relic acquired: ${relic.name}`);
    }

    function addGold(amount) {
      const bonus = state.goldBonus || 0;
      const total = amount * (1 + bonus);
      state.gold += total;
      state.stats.goldEarned += total;
    }

    function castNova() {
      if (state.mana < 50) return;
      state.mana -= 50;
      const bonus = state.novaBonus || 0;
      const damage = 40 * (1 + bonus);
      state.enemies.forEach((enemy) => {
        enemy.hp -= damage;
      });
      state.effects.push({ type: "nova", time: 0 });
      showToast("Arcane Nova unleashed!");
    }

    function updateEnemies(delta) {
      const weather = getWeatherModifiers();
      const dayBonus = state.dayNight === "Night" ? 1.08 : 0.95;
      const speedPenalty = 1 + (state.enemySpeedBonus || 0);
      state.enemies = state.enemies.filter((enemy) => enemy.hp > 0);
      state.enemies.forEach((enemy) => {
        if (enemy.delay > 0) {
          enemy.delay -= delta * 1000;
          return;
        }
        const slowMultiplier = enemy.slow ? 1 - enemy.slow : 1;
        const speed = enemy.speed * weather.enemySpeed * dayBonus * slowMultiplier * speedPenalty;
        enemy.progress += speed * delta;
        enemy.slow = Math.max(0, enemy.slow - delta * 0.2);
        enemy.hp -= (enemy.burn + enemy.poison) * delta;
        if (enemy.progress >= getPathLength()) {
          damageBase(enemy.boss ? 40 : 20);
          enemy.hp = 0;
        }
      });
    }

    function updateTowers(delta) {
      state.towers.forEach((tower) => {
        tower.cooldown -= delta;
        if (tower.cooldown <= 0) {
          const target = findTarget(tower.x, tower.y, tower.range);
          if (target) {
            fireProjectile(tower, target, "tower");
            tower.cooldown = 1 / tower.fireRate;
          }
        }
      });
    }

    function updateHero(delta) {
      state.hero.cooldown -= delta;
      if (state.hero.cooldown <= 0) {
        const target = findTarget(state.hero.x, state.hero.y, state.wand.stats.range);
        if (target) {
          fireProjectile(state.hero, target, "hero");
          const bonus = state.heroCooldownBonus || 0;
          state.hero.cooldown = state.wand.stats.fireRate * (1 - bonus);
          if (state.wand.stats.manaDrain) {
            state.mana = Math.max(0, state.mana - state.wand.stats.manaDrain);
          }
        }
      }
    }

    function fireProjectile(source, target, owner) {
      const wandStats = owner === "hero" ? state.wand.stats : null;
      const baseDamage = owner === "hero" ? wandStats.damage : source.damage;
      const critChance = owner === "hero" ? wandStats.crit : 0.08;
      const synergy = owner === "hero" ? 0 : getTowerSynergy(source);
      const crit = Math.random() < critChance;
      const damage = baseDamage * (crit ? 1.8 : 1) * (1 + (state.towerDamageBonus || 0) + synergy);
      state.projectiles.push({
        x: source.x,
        y: source.y,
        target,
        speed: 340,
        damage,
        crit,
        owner,
        stats: wandStats || source,
        chainLeft: (wandStats?.chain || source.chain || 0) + (state.chainBonus || 0)
      });
    }

    function getTowerSynergy(tower) {
      const neighbors = [
        [1, 0],
        [-1, 0],
        [0, 1],
        [0, -1]
      ];
      let bonus = 0;
      neighbors.forEach(([dx, dy]) => {
        const neighbor = state.towers.find(
          (item) => item.gridX === tower.gridX + dx && item.gridY === tower.gridY + dy
        );
        if (neighbor && neighbor.type !== tower.type) bonus += 0.05;
      });
      return bonus;
    }

    function updateProjectiles(delta) {
      const weather = getWeatherModifiers();
      state.projectiles = state.projectiles.filter((projectile) => projectile.target.hp > 0);
      state.projectiles.forEach((projectile) => {
        const dx = projectile.target.x - projectile.x;
        const dy = projectile.target.y - projectile.y;
        const dist = Math.hypot(dx, dy);
        const speed = projectile.speed * weather.projectileSpeed;
        if (dist < speed * delta) {
          applyDamage(projectile.target, projectile);
          projectile.hit = true;
        } else {
          projectile.x += (dx / dist) * speed * delta;
          projectile.y += (dy / dist) * speed * delta;
        }
      });
      state.projectiles = state.projectiles.filter((projectile) => !projectile.hit);
    }

    function applyDamage(target, projectile) {
      target.hp -= projectile.damage;
      if (projectile.stats?.burn) target.burn = Math.max(target.burn, projectile.stats.burn);
      if (projectile.stats?.slow) target.slow = Math.max(target.slow, projectile.stats.slow);
      if (projectile.stats?.poison) target.poison = Math.max(target.poison, projectile.stats.poison);
      if (projectile.chainLeft > 0) {
        const next = findTarget(target.x, target.y, 120, target.id);
        if (next) {
          state.projectiles.push({
            x: target.x,
            y: target.y,
            target: next,
            speed: 300,
            damage: projectile.damage * 0.8,
            crit: false,
            owner: projectile.owner,
            stats: projectile.stats,
            chainLeft: projectile.chainLeft - 1
          });
        }
      }
      if (target.hp <= 0) {
        handleEnemyDeath(target);
      }
    }

    function handleEnemyDeath(enemy) {
      state.stats.kills += 1;
      updateCombo();
      addGold(enemy.bounty);
      if (enemy.type.id === "elite") {
        spawnLoot(enemy.x, enemy.y, 24);
      }
      if (enemy.boss) {
        state.stats.bossesDefeated += 1;
        spawnRelic();
        spawnLoot(enemy.x, enemy.y, 40);
      }
      if (!enemy.boss && Math.random() < 0.1) {
        spawnLoot(enemy.x, enemy.y, 12);
      }
      if (state.stats.kills % 20 === 0) {
        showToast("Achievement: Slayer streak!");
      }
    }

    function updateCombo() {
      if (state.combo.timer > 0) {
        state.combo.count += 1;
      } else {
        state.combo.count = 1;
      }
      state.combo.timer = 3;
      if (state.combo.count % 5 === 0) {
        state.mana = Math.min(state.manaMax, state.mana + 10);
        showToast(`Combo x${state.combo.count}! Mana surge.`);
      }
    }

    function spawnLoot(x, y, value) {
      state.loot.push({ x, y, value, timer: 3 });
    }

    function updateLoot(delta) {
      state.loot.forEach((drop) => {
        drop.timer -= delta;
      });
      const collected = state.loot.filter((drop) => drop.timer <= 0);
      collected.forEach((drop) => addGold(drop.value));
      state.loot = state.loot.filter((drop) => drop.timer > 0);
    }

    function updateWaveState() {
      if (state.waveInProgress && state.enemies.length === 0) {
        state.waveInProgress = false;
        state.stats.wavesCleared += 1;
        spawnRuneOptions();
        showToast("Wave cleared! Choose a rune.");
      }
    }

    function damageBase(amount) {
      state.baseHp -= amount;
      if (state.baseHp <= 0) {
        if (state.reviveToken) {
          state.reviveToken = false;
          state.baseHp = state.baseHpMax * 0.3;
          showToast("Phoenix Crest revived the crystal!");
        } else {
          state.running = false;
          showToast("The crystal has fallen.");
        }
      }
    }

    function regenerate(delta) {
      const regen = state.dayNight === "Night" ? 6 : 4;
      state.mana = Math.min(state.manaMax, state.mana + regen * delta);
      if (!state.waveInProgress) {
        state.baseHp = Math.min(state.baseHpMax, state.baseHp + 4 * delta);
      }
    }

    function updateComboTimer(delta) {
      if (state.combo.timer > 0) {
        state.combo.timer -= delta;
        if (state.combo.timer <= 0) state.combo.count = 0;
      }
    }

    function updateEnvironment(delta) {
      state.weatherTimer += delta;
      state.dayTimer += delta;
      if (state.weatherTimer > 22) {
        state.weatherTimer = 0;
        const weather = weatherStates[Math.floor(Math.random() * weatherStates.length)];
        state.weather = weather.name;
        showToast(`Weather shifted: ${weather.name}`);
      }
      if (state.dayTimer > 28) {
        state.dayTimer = 0;
        state.dayNight = state.dayNight === "Day" ? "Night" : "Day";
      }
    }

    function getWeatherModifiers() {
      return weatherStates.find((weather) => weather.name === state.weather) || weatherStates[0];
    }

    function getPathLength() {
      let length = 0;
      for (let i = 0; i < path.length - 1; i += 1) {
        const dx = (path[i + 1].x - path[i].x) * grid.size;
        const dy = (path[i + 1].y - path[i].y) * grid.size;
        length += Math.hypot(dx, dy);
      }
      return length;
    }

    function getPositionOnPath(progress) {
      let remaining = progress;
      for (let i = 0; i < path.length - 1; i += 1) {
        const start = path[i];
        const end = path[i + 1];
        const dx = (end.x - start.x) * grid.size;
        const dy = (end.y - start.y) * grid.size;
        const segment = Math.hypot(dx, dy);
        if (remaining <= segment) {
          return {
            x: start.x * grid.size + (dx / segment) * remaining + grid.size / 2,
            y: start.y * grid.size + (dy / segment) * remaining + grid.size / 2
          };
        }
        remaining -= segment;
      }
      const last = path[path.length - 1];
      return { x: last.x * grid.size + grid.size / 2, y: last.y * grid.size + grid.size / 2 };
    }

    function findTarget(x, y, range, ignoreId) {
      return state.enemies
        .filter((enemy) => enemy.hp > 0 && enemy.id !== ignoreId && enemy.delay <= 0)
        .map((enemy) => ({ enemy, pos: getPositionOnPath(enemy.progress) }))
        .map(({ enemy, pos }) => ({ enemy, dist: Math.hypot(pos.x - x, pos.y - y), pos }))
        .filter(({ dist }) => dist <= range)
        .sort((a, b) => b.enemy.progress - a.enemy.progress)[0]?.enemy || null;
    }

    function placeTower(type, gridX, gridY) {
      const towerType = towerCatalog[type];
      if (state.gold < towerType.cost) return;
      if (isPathTile(gridX, gridY)) return;
      if (state.towers.some((tower) => tower.gridX === gridX && tower.gridY === gridY)) return;
      const tower = {
        id: crypto.randomUUID(),
        type,
        gridX,
        gridY,
        x: gridX * grid.size + grid.size / 2,
        y: gridY * grid.size + grid.size / 2,
        damage: towerType.damage,
        fireRate: towerType.fireRate,
        range: towerType.range,
        cost: towerType.cost,
        level: 1,
        cooldown: 0,
        color: towerType.color,
        burn: towerType.burn || 0,
        slow: towerType.slow || 0,
        chain: towerType.chain || 0
      };
      state.towers.push(tower);
      state.gold -= tower.cost;
      showToast(`${towerType.name} tower placed.`);
    }

    function upgradeTower() {
      const tower = state.towers.find((item) => item.id === state.selectedTowerId);
      if (!tower) return;
      const cost = Math.floor(tower.cost * 0.7);
      if (state.gold < cost) return;
      state.gold -= cost;
      tower.level += 1;
      tower.damage *= 1.2;
      tower.range += 8;
      tower.fireRate *= 1.08;
      showToast("Tower upgraded.");
    }

    function sellTower() {
      const towerIndex = state.towers.findIndex((item) => item.id === state.selectedTowerId);
      if (towerIndex < 0) return;
      const tower = state.towers[towerIndex];
      state.gold += tower.cost * 0.6;
      state.towers.splice(towerIndex, 1);
      state.selectedTowerId = null;
      showToast("Tower sold.");
    }

    function isPathTile(x, y) {
      for (let i = 0; i < path.length - 1; i += 1) {
        const start = path[i];
        const end = path[i + 1];
        if (start.x === end.x) {
          const minY = Math.min(start.y, end.y);
          const maxY = Math.max(start.y, end.y);
          if (x === start.x && y >= minY && y <= maxY) return true;
        } else {
          const minX = Math.min(start.x, end.x);
          const maxX = Math.max(start.x, end.x);
          if (y === start.y && x >= minX && x <= maxX) return true;
        }
      }
      return false;
    }

    function drawGrid() {
      ctx.strokeStyle = "rgba(255,255,255,0.05)";
      for (let x = 0; x <= grid.cols; x += 1) {
        ctx.beginPath();
        ctx.moveTo(x * grid.size, 0);
        ctx.lineTo(x * grid.size, grid.rows * grid.size);
        ctx.stroke();
      }
      for (let y = 0; y <= grid.rows; y += 1) {
        ctx.beginPath();
        ctx.moveTo(0, y * grid.size);
        ctx.lineTo(grid.cols * grid.size, y * grid.size);
        ctx.stroke();
      }
    }

    function drawPath() {
      ctx.strokeStyle = "rgba(127,124,255,0.45)";
      ctx.lineWidth = 18;
      ctx.lineCap = "round";
      ctx.beginPath();
      path.forEach((point, index) => {
        const px = point.x * grid.size + grid.size / 2;
        const py = point.y * grid.size + grid.size / 2;
        if (index === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      });
      ctx.stroke();
      ctx.lineWidth = 1;
    }

    function drawTowers() {
      state.towers.forEach((tower) => {
        ctx.fillStyle = tower.color;
        ctx.beginPath();
        ctx.arc(tower.x, tower.y, 16, 0, Math.PI * 2);
        ctx.fill();
        if (tower.id === state.selectedTowerId) {
          ctx.strokeStyle = "#ffffff";
          ctx.beginPath();
          ctx.arc(tower.x, tower.y, tower.range, 0, Math.PI * 2);
          ctx.stroke();
        }
      });
    }

    function drawHero() {
      ctx.fillStyle = "#7f7cff";
      ctx.beginPath();
      ctx.arc(state.hero.x, state.hero.y, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#ffffff";
      ctx.font = "12px sans-serif";
      ctx.fillText(state.wand.element, state.hero.x - 20, state.hero.y + 4);
    }

    function drawEnemies() {
      state.enemies.forEach((enemy) => {
        if (enemy.delay > 0) return;
        const pos = getPositionOnPath(enemy.progress);
        enemy.x = pos.x;
        enemy.y = pos.y;
        ctx.fillStyle = enemy.type.color;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, enemy.boss ? 18 : 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(pos.x - 18, pos.y - 22, 36, 4);
        ctx.fillStyle = enemy.type.boss ? "#ff5f7a" : "#7f7cff";
        ctx.fillRect(pos.x - 18, pos.y - 22, 36 * (enemy.hp / enemy.maxHp), 4);
        if (enemy.burn > 0) {
          ctx.fillStyle = "#ff825c";
          ctx.fillText("ðŸ”¥", pos.x - 4, pos.y - 18);
        }
        if (enemy.slow > 0.05) {
          ctx.fillStyle = "#66d0ff";
          ctx.fillText("â„", pos.x + 4, pos.y - 18);
        }
      });
    }

    function drawProjectiles() {
      state.projectiles.forEach((projectile) => {
        ctx.strokeStyle = projectile.owner === "hero" ? "#9ee4ff" : "#f7c96b";
        ctx.beginPath();
        ctx.arc(projectile.x, projectile.y, projectile.crit ? 4 : 3, 0, Math.PI * 2);
        ctx.stroke();
      });
    }

    function drawLoot() {
      state.loot.forEach((drop) => {
        ctx.fillStyle = "#f7c96b";
        ctx.beginPath();
        ctx.arc(drop.x, drop.y, 6, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawEnvironmentOverlay() {
      if (state.dayNight === "Night") {
        ctx.fillStyle = "rgba(9, 12, 25, 0.35)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      if (state.weather === "Fog") {
        ctx.fillStyle = "rgba(120, 140, 180, 0.2)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    function loop(timestamp) {
      if (!state.lastTime) state.lastTime = timestamp;
      const delta = ((timestamp - state.lastTime) / 1000) * state.speed;
      state.lastTime = timestamp;
      if (state.running) {
        updateEnvironment(delta);
        updateEnemies(delta);
        updateTowers(delta);
        updateHero(delta);
        updateProjectiles(delta);
        updateLoot(delta);
        updateComboTimer(delta);
        updateWaveState();
        regenerate(delta);
      }
      render();
      updateUI();
      requestAnimationFrame(loop);
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid();
      drawPath();
      drawTowers();
      drawHero();
      drawEnemies();
      drawProjectiles();
      drawLoot();
      drawEnvironmentOverlay();
    }

    canvas.addEventListener("click", (event) => {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const gridX = Math.floor((x / rect.width) * canvas.width / grid.size);
      const gridY = Math.floor((y / rect.height) * canvas.height / grid.size);
      const tower = state.towers.find((item) => item.gridX === gridX && item.gridY === gridY);
      if (tower) {
        state.selectedTowerId = tower.id;
      }
    });

    canvas.addEventListener("mousemove", (event) => {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const gridX = Math.floor((x / rect.width) * canvas.width / grid.size);
      const gridY = Math.floor((y / rect.height) * canvas.height / grid.size);
      const tower = state.towers.find((item) => item.gridX === gridX && item.gridY === gridY);
      canvas.title = tower
        ? `${tower.type.toUpperCase()} LV${tower.level}\nDamage ${tower.damage.toFixed(1)}\nRange ${tower.range.toFixed(0)}\nRate ${tower.fireRate.toFixed(2)}`
        : "";
    });

    canvas.addEventListener("contextmenu", (event) => {
      event.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const gridX = Math.floor((x / rect.width) * canvas.width / grid.size);
      const gridY = Math.floor((y / rect.height) * canvas.height / grid.size);
      const towerIndex = state.towers.findIndex((item) => item.gridX === gridX && item.gridY === gridY);
      if (towerIndex >= 0) {
        state.selectedTowerId = state.towers[towerIndex].id;
        sellTower();
      }
    });

    ui.startWave.addEventListener("click", () => {
      state.running = true;
      spawnWave();
    });

    ui.pause.addEventListener("click", () => {
      state.running = !state.running;
      ui.pause.textContent = state.running ? "Pause" : "Resume";
    });

    ui.speed.addEventListener("click", () => {
      state.speed = state.speed === 1 ? 1.6 : 1;
      ui.speed.textContent = state.speed === 1 ? "Speed x1" : "Speed x1.6";
    });

    ui.nova.addEventListener("click", () => {
      castNova();
    });

    ui.wandSelect.addEventListener("change", (event) => {
      const wand = state.wandInventory.find((item) => item.id === event.target.value);
      if (wand) {
        state.wand = wand;
        renderWandDetails();
      }
    });

    ui.buildButtons.arcane.addEventListener("click", () => (state.pendingBuild = "arcane"));
    ui.buildButtons.frost.addEventListener("click", () => (state.pendingBuild = "frost"));
    ui.buildButtons.flame.addEventListener("click", () => (state.pendingBuild = "flame"));
    ui.buildButtons.storm.addEventListener("click", () => (state.pendingBuild = "storm"));

    ui.sell.addEventListener("click", sellTower);
    ui.upgrade.addEventListener("click", upgradeTower);

    canvas.addEventListener("mousedown", (event) => {
      if (!state.pendingBuild) return;
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const gridX = Math.floor((x / rect.width) * canvas.width / grid.size);
      const gridY = Math.floor((y / rect.height) * canvas.height / grid.size);
      placeTower(state.pendingBuild, gridX, gridY);
      state.pendingBuild = null;
    });

    document.addEventListener("keydown", (event) => {
      if (event.key === "n") castNova();
      if (event.key === "p") state.running = !state.running;
    });

    init();
  </script>
</body>
</html>
