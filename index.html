<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Neon Loop: Hyper Pulse Arena</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: "Inter", system-ui, sans-serif;
      --bg: #05060c;
      --panel: #101626;
      --panel-2: #171f34;
      --accent: #6df3ff;
      --accent-2: #ff7ad9;
      --warning: #f7c96b;
      --danger: #ff6b6b;
      --text: #f6f8ff;
      --muted: #8c95b8;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: radial-gradient(circle at top, #121b37 0%, #04050a 60%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 20px 32px 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }

    h1 {
      margin: 0;
      font-size: 24px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .subtitle {
      color: var(--muted);
      font-size: 14px;
      max-width: 520px;
    }

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button, select {
      background: var(--panel-2);
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      transition: transform 0.15s ease, border 0.15s ease;
    }

    button:hover, select:hover {
      border-color: rgba(255,255,255,0.4);
      transform: translateY(-1px);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .hud {
      display: grid;
      grid-template-columns: 3fr 1.2fr;
      gap: 16px;
      padding: 0 32px 28px;
      flex: 1;
    }

    .panel {
      background: linear-gradient(145deg, rgba(16,22,38,0.95), rgba(7,10,18,0.95));
      border: 1px solid rgba(128, 140, 190, 0.2);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.35);
    }

    #game-wrap {
      position: relative;
      overflow: hidden;
    }

    canvas {
      width: 100%;
      height: 100%;
      border-radius: 14px;
      background: #05070d;
      border: 1px solid rgba(255,255,255,0.06);
    }

    .column {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
      font-size: 13px;
    }

    .stat {
      background: var(--panel-2);
      padding: 8px 10px;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .stat strong {
      font-size: 16px;
    }

    .progress {
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      overflow: hidden;
    }

    .progress span {
      display: block;
      height: 100%;
      background: linear-gradient(90deg, var(--accent), #9ee4ff);
      width: 50%;
      transition: width 0.2s ease;
    }

    .card {
      background: rgba(28,34,52,0.9);
      border-radius: 12px;
      padding: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      display: grid;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    .list {
      display: grid;
      gap: 6px;
      font-size: 12px;
      max-height: 190px;
      overflow: auto;
    }

    .list span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: var(--muted);
    }

    .list span::before {
      content: "✦";
      color: var(--accent-2);
      font-size: 12px;
    }

    .upgrade-buttons {
      display: grid;
      gap: 8px;
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      font-size: 12px;
    }

    .legend span {
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(109,243,255,0.18);
      border: 1px solid rgba(109,243,255,0.4);
    }

    .toast {
      position: absolute;
      right: 20px;
      top: 20px;
      background: rgba(21,25,41,0.95);
      border: 1px solid rgba(255,255,255,0.08);
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 12px;
      display: none;
      max-width: 240px;
    }

    .toast.show {
      display: block;
    }

    footer {
      padding: 0 32px 24px;
      color: var(--muted);
      font-size: 12px;
    }

    @media (max-width: 1100px) {
      .hud {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Neon Loop: Hyper Pulse Arena</h1>
      <div class="subtitle">
        A hyperactive arena loop: dash, shoot, and chain streaks to unlock permanent meta upgrades. Every run remixes spawns, hazards, and reward cards for high replayability.
      </div>
    </div>
    <div class="controls">
      <button id="start-run">Start Run</button>
      <button id="toggle-pause">Pause</button>
      <button id="toggle-speed">Speed x1</button>
      <button id="cast-burst">Pulse Burst (40 energy)</button>
    </div>
  </header>

  <section class="hud">
    <div class="panel" id="game-wrap">
      <canvas id="arena" width="960" height="540"></canvas>
      <div class="toast" id="toast"></div>
    </div>
    <div class="column">
      <div class="panel">
        <h3>Run HUD</h3>
        <div class="stat-grid">
          <div class="stat">
            <span>Score</span>
            <strong id="score">0</strong>
          </div>
          <div class="stat">
            <span>Combo</span>
            <strong id="combo">x0</strong>
          </div>
          <div class="stat">
            <span>Integrity</span>
            <strong id="hp">0</strong>
            <div class="progress"><span id="hp-bar"></span></div>
          </div>
          <div class="stat">
            <span>Energy</span>
            <strong id="energy">0</strong>
            <div class="progress"><span id="energy-bar"></span></div>
          </div>
          <div class="stat">
            <span>Loop</span>
            <strong id="loop">0</strong>
          </div>
          <div class="stat">
            <span>Difficulty</span>
            <strong id="difficulty">0</strong>
          </div>
          <div class="stat">
            <span>Best</span>
            <strong id="best">0</strong>
          </div>
          <div class="stat">
            <span>Meta Chips</span>
            <strong id="chips">0</strong>
          </div>
          <div class="stat">
            <span>Threat</span>
            <strong id="threat">0</strong>
          </div>
          <div class="stat">
            <span>Overdrive</span>
            <strong id="overdrive">0</strong>
            <div class="progress"><span id="overdrive-bar"></span></div>
          </div>
        </div>
      </div>

      <div class="panel">
        <h3>Loadout Cards</h3>
        <div class="card" id="loadout">Pick a card between loops to evolve your build.</div>
        <div class="upgrade-buttons" id="card-options"></div>
      </div>

      <div class="panel">
        <h3>Meta Lab (Persistent)</h3>
        <div class="upgrade-buttons">
          <button id="meta-shield">+20 Max Integrity (40 chips)</button>
          <button id="meta-energy">+15 Max Energy (40 chips)</button>
          <button id="meta-dash">Dash Cooldown -10% (50 chips)</button>
          <button id="meta-fire">Fire Rate +10% (50 chips)</button>
        </div>
      </div>

      <div class="panel">
        <h3>Active Tips</h3>
        <div class="list" id="tips"></div>
      </div>

      <div class="panel">
        <h3>Active Buffs</h3>
        <div class="list" id="buffs"></div>
      </div>

      <div class="panel">
        <h3>Control Legend</h3>
        <div class="legend">
          <span>WASD / Arrow Keys: Move</span>
          <span>Mouse: Aim</span>
          <span>Click / Space: Fire</span>
          <span>Shift: Dash</span>
          <span>E: Pulse Burst</span>
        </div>
      </div>
    </div>
  </section>

  <footer>
    Tip: Keep the combo alive by chaining kills within three seconds. Every loop offers different enemy mixes and reward cards.
  </footer>

  <script>
    const canvas = document.getElementById("arena");
    const ctx = canvas.getContext("2d");

    const ui = {
      score: document.getElementById("score"),
      combo: document.getElementById("combo"),
      hp: document.getElementById("hp"),
      hpBar: document.getElementById("hp-bar"),
      energy: document.getElementById("energy"),
      energyBar: document.getElementById("energy-bar"),
      loop: document.getElementById("loop"),
      difficulty: document.getElementById("difficulty"),
      best: document.getElementById("best"),
      chips: document.getElementById("chips"),
      threat: document.getElementById("threat"),
      overdrive: document.getElementById("overdrive"),
      overdriveBar: document.getElementById("overdrive-bar"),
      loadout: document.getElementById("loadout"),
      cardOptions: document.getElementById("card-options"),
      tips: document.getElementById("tips"),
      buffs: document.getElementById("buffs"),
      toast: document.getElementById("toast"),
      startRun: document.getElementById("start-run"),
      pause: document.getElementById("toggle-pause"),
      speed: document.getElementById("toggle-speed"),
      burst: document.getElementById("cast-burst"),
      metaShield: document.getElementById("meta-shield"),
      metaEnergy: document.getElementById("meta-energy"),
      metaDash: document.getElementById("meta-dash"),
      metaFire: document.getElementById("meta-fire")
    };

    const tips = [
      "Dash through enemies to avoid stagger during invuln frames.",
      "Pulse Burst clears hazard mines and refuels your combo timer.",
      "Overdrive doubles fire rate briefly; save it for bosses.",
      "Threat rises each loop and drives hazard intensity.",
      "Chain kills within 3 seconds to ramp your score multiplier.",
      "Magnet buff makes chip pickups drift in faster."
    ];

    const cardCatalog = [
      { name: "Arc Coil", text: "Shots chain once to a nearby target.", apply: () => { state.chain += 1; } },
      { name: "Flux Barrage", text: "+20% fire rate.", apply: () => { state.fireRate *= 1.2; } },
      { name: "Overclock Shield", text: "Regenerate 2 integrity per loop.", apply: () => { state.loopRegen += 2; } },
      { name: "Lumen Rounds", text: "Shots pierce 1 enemy.", apply: () => { state.pierce += 1; } },
      { name: "Magnet Core", text: "Pickups pull from farther away.", apply: () => { state.pickupRange += 40; } },
      { name: "Thermal Burst", text: "Pulse Burst deals +40% damage.", apply: () => { state.burstPower += 0.4; } }
    ];

    const enemyTypes = [
      { id: "drifter", name: "Drifter", hp: 22, speed: 70, color: "#6df3ff", score: 18 },
      { id: "crusher", name: "Crusher", hp: 60, speed: 45, color: "#ff7ad9", score: 36 },
      { id: "swarm", name: "Swarm", hp: 14, speed: 90, color: "#f7c96b", score: 14 },
      { id: "phantom", name: "Phantom", hp: 40, speed: 80, color: "#8b8bff", score: 30 },
      { id: "warden", name: "Warden", hp: 120, speed: 50, color: "#ff6b6b", score: 80, boss: true }
    ];

    const state = {
      running: false,
      speed: 1,
      score: 0,
      best: Number(localStorage.getItem("neon-loop-best") || 0),
      chips: Number(localStorage.getItem("neon-loop-chips") || 0),
      loop: 0,
      difficulty: 1,
      threat: 1,
      combo: { count: 0, timer: 0 },
      player: {
        x: canvas.width / 2,
        y: canvas.height / 2,
        radius: 16,
        speed: 220,
        hp: 100,
        maxHp: 100,
        energy: 60,
        maxEnergy: 60,
        dashCooldown: 0,
        dashTimer: 0
      },
      fireRate: 7,
      chain: 0,
      pierce: 0,
      loopRegen: 0,
      pickupRange: 120,
      burstPower: 0,
      overdriveTimer: 0,
      shieldTimer: 0,
      magnetTimer: 0,
      bullets: [],
      enemies: [],
      pickups: [],
      hazards: [],
      particles: [],
      keys: {},
      mouse: { x: canvas.width / 2, y: canvas.height / 2, down: false },
      lastTime: 0,
      spawnTimer: 0,
      loopTimer: 0,
      ringTimer: 8,
      mineTimer: 6,
      fireTimer: 0
    };

    function showToast(message) {
      ui.toast.textContent = message;
      ui.toast.classList.add("show");
      clearTimeout(state.toastTimer);
      state.toastTimer = setTimeout(() => ui.toast.classList.remove("show"), 2200);
    }

    function updateUI() {
      ui.score.textContent = Math.floor(state.score);
      ui.combo.textContent = `x${state.combo.count}`;
      ui.hp.textContent = `${Math.floor(state.player.hp)}/${state.player.maxHp}`;
      ui.hpBar.style.width = `${(state.player.hp / state.player.maxHp) * 100}%`;
      ui.energy.textContent = `${Math.floor(state.player.energy)}/${state.player.maxEnergy}`;
      ui.energyBar.style.width = `${(state.player.energy / state.player.maxEnergy) * 100}%`;
      ui.loop.textContent = state.loop;
      ui.difficulty.textContent = state.difficulty.toFixed(1);
      ui.best.textContent = state.best;
      ui.chips.textContent = state.chips;
      ui.threat.textContent = state.threat.toFixed(1);
      ui.overdrive.textContent = state.overdriveTimer > 0 ? `${state.overdriveTimer.toFixed(1)}s` : "0";
      ui.overdriveBar.style.width = `${Math.min(100, (state.overdriveTimer / 6) * 100)}%`;
      renderBuffs();
    }

    function renderTips() {
      ui.tips.innerHTML = "";
      tips.forEach((tip) => {
        const span = document.createElement("span");
        span.textContent = tip;
        ui.tips.appendChild(span);
      });
    }

    function renderBuffs() {
      ui.buffs.innerHTML = "";
      const buffs = [];
      if (state.overdriveTimer > 0) buffs.push(`Overdrive ${state.overdriveTimer.toFixed(1)}s`);
      if (state.shieldTimer > 0) buffs.push(`Shield ${state.shieldTimer.toFixed(1)}s`);
      if (state.magnetTimer > 0) buffs.push(`Magnet ${state.magnetTimer.toFixed(1)}s`);
      if (buffs.length === 0) buffs.push("No active buffs.");
      buffs.forEach((buff) => {
        const span = document.createElement("span");
        span.textContent = buff;
        ui.buffs.appendChild(span);
      });
    }

    function resetRun() {
      state.score = 0;
      state.loop = 0;
      state.difficulty = 1;
      state.threat = 1;
      state.combo = { count: 0, timer: 0 };
      state.player.x = canvas.width / 2;
      state.player.y = canvas.height / 2;
      state.player.hp = state.player.maxHp;
      state.player.energy = state.player.maxEnergy;
      state.player.dashCooldown = 0;
      state.player.dashTimer = 0;
      state.fireRate = 7;
      state.chain = 0;
      state.pierce = 0;
      state.loopRegen = 0;
      state.pickupRange = 120;
      state.burstPower = 0;
      state.overdriveTimer = 0;
      state.shieldTimer = 0;
      state.magnetTimer = 0;
      state.bullets = [];
      state.enemies = [];
      state.pickups = [];
      state.hazards = [];
      state.particles = [];
      state.spawnTimer = 0;
      state.loopTimer = 0;
      state.ringTimer = 8;
      state.mineTimer = 6;
      state.fireTimer = 0;
      ui.cardOptions.innerHTML = "";
      ui.loadout.textContent = "Pick a card between loops to evolve your build.";
      showToast("Loop initialized. Survive the surge!");
    }

    function applyMetaUpgrades() {
      const meta = JSON.parse(localStorage.getItem("neon-loop-meta") || "{}");
      if (meta.shield) state.player.maxHp = 100 + meta.shield;
      if (meta.energy) state.player.maxEnergy = 60 + meta.energy;
      if (meta.dash) state.player.dashCooldownMax = 0.8 - meta.dash;
      if (meta.fire) state.fireRate += meta.fire;
    }

    function saveMeta(meta) {
      localStorage.setItem("neon-loop-meta", JSON.stringify(meta));
    }

    function loadMeta() {
      const meta = JSON.parse(localStorage.getItem("neon-loop-meta") || "{}");
      meta.shield = meta.shield || 0;
      meta.energy = meta.energy || 0;
      meta.dash = meta.dash || 0;
      meta.fire = meta.fire || 0;
      saveMeta(meta);
      return meta;
    }

    const metaState = loadMeta();
    applyMetaUpgrades();

    function updateMetaButtons() {
      ui.metaShield.disabled = state.chips < 40;
      ui.metaEnergy.disabled = state.chips < 40;
      ui.metaDash.disabled = state.chips < 50;
      ui.metaFire.disabled = state.chips < 50;
    }

    function spendChips(amount) {
      if (state.chips < amount) return false;
      state.chips -= amount;
      localStorage.setItem("neon-loop-chips", state.chips);
      return true;
    }

    function handleMetaUpgrade(key, cost, amount, message) {
      if (!spendChips(cost)) return;
      metaState[key] += amount;
      saveMeta(metaState);
      applyMetaUpgrades();
      showToast(message);
      updateMetaButtons();
    }

    ui.metaShield.addEventListener("click", () => handleMetaUpgrade("shield", 40, 20, "Max integrity +20"));
    ui.metaEnergy.addEventListener("click", () => handleMetaUpgrade("energy", 40, 15, "Max energy +15"));
    ui.metaDash.addEventListener("click", () => handleMetaUpgrade("dash", 50, 0.06, "Dash cooldown improved"));
    ui.metaFire.addEventListener("click", () => handleMetaUpgrade("fire", 50, 0.6, "Fire rate improved"));

    function spawnCardOptions() {
      ui.cardOptions.innerHTML = "";
      const choices = [...cardCatalog].sort(() => 0.5 - Math.random()).slice(0, 3);
      choices.forEach((card) => {
        const button = document.createElement("button");
        button.textContent = `${card.name} — ${card.text}`;
        button.addEventListener("click", () => {
          card.apply();
          ui.cardOptions.innerHTML = "";
          ui.loadout.textContent = `Active card: ${card.name}`;
          showToast(`Card equipped: ${card.name}`);
        });
        ui.cardOptions.appendChild(button);
      });
    }

    function spawnEnemy() {
      const pool = enemyTypes.filter((type) => !type.boss);
      let type = pool[Math.floor(Math.random() * pool.length)];
      if (Math.random() < 0.1 + state.loop * 0.02) {
        type = enemyTypes.find((enemy) => enemy.id === "crusher");
      }
      const edge = Math.floor(Math.random() * 4);
      const spawn = { x: 0, y: 0 };
      if (edge === 0) {
        spawn.x = Math.random() * canvas.width;
        spawn.y = -30;
      } else if (edge === 1) {
        spawn.x = canvas.width + 30;
        spawn.y = Math.random() * canvas.height;
      } else if (edge === 2) {
        spawn.x = Math.random() * canvas.width;
        spawn.y = canvas.height + 30;
      } else {
        spawn.x = -30;
        spawn.y = Math.random() * canvas.height;
      }
      const hpScale = 1 + state.difficulty * 0.15;
      const speedScale = 1 + state.difficulty * 0.05;
      state.enemies.push({
        id: crypto.randomUUID(),
        type,
        x: spawn.x,
        y: spawn.y,
        hp: type.hp * hpScale,
        maxHp: type.hp * hpScale,
        speed: type.speed * speedScale,
        hitTimer: 0
      });
    }

    function spawnBoss() {
      const type = enemyTypes.find((enemy) => enemy.boss);
      const hpScale = 1 + state.difficulty * 0.25;
      state.enemies.push({
        id: crypto.randomUUID(),
        type,
        x: canvas.width / 2,
        y: -40,
        hp: type.hp * hpScale,
        maxHp: type.hp * hpScale,
        speed: type.speed,
        boss: true,
        hitTimer: 0
      });
      showToast("Loop boss incoming! Clear it for extra chips.");
    }

    function shoot() {
      if (state.player.energy <= 0) return;
      const dx = state.mouse.x - state.player.x;
      const dy = state.mouse.y - state.player.y;
      const dist = Math.hypot(dx, dy) || 1;
      const angle = Math.atan2(dy, dx);
      const speed = 520;
      state.bullets.push({
        x: state.player.x,
        y: state.player.y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 1.4,
        pierce: state.pierce
      });
      state.player.energy = Math.max(0, state.player.energy - 1.2);
      spawnParticles(state.player.x, state.player.y, "#6df3ff");
    }

    function castBurst() {
      if (state.player.energy < 40) return;
      state.player.energy -= 40;
      const power = 35 * (1 + state.burstPower);
      state.enemies.forEach((enemy) => {
        enemy.hp -= power;
        enemy.hitTimer = 0.2;
      });
      state.combo.timer = 3;
      spawnParticles(state.player.x, state.player.y, "#ff7ad9", 40);
      showToast("Pulse Burst detonated!");
    }

    function spawnPickup(x, y, value, type) {
      state.pickups.push({ x, y, value, type, timer: 8 });
    }

    function spawnBuffPickup(x, y) {
      const types = ["overdrive", "shield", "magnet"];
      const type = types[Math.floor(Math.random() * types.length)];
      state.pickups.push({ x, y, value: 0, type, timer: 10 });
    }

    function spawnParticles(x, y, color, count = 16) {
      for (let i = 0; i < count; i += 1) {
        state.particles.push({
          x,
          y,
          vx: (Math.random() - 0.5) * 200,
          vy: (Math.random() - 0.5) * 200,
          life: 0.8,
          color
        });
      }
    }

    function updatePlayer(delta) {
      const speed = state.player.speed * (state.player.dashTimer > 0 ? 1.8 : 1);
      let dx = 0;
      let dy = 0;
      if (state.keys["ArrowUp"] || state.keys["w"]) dy -= 1;
      if (state.keys["ArrowDown"] || state.keys["s"]) dy += 1;
      if (state.keys["ArrowLeft"] || state.keys["a"]) dx -= 1;
      if (state.keys["ArrowRight"] || state.keys["d"]) dx += 1;
      const length = Math.hypot(dx, dy) || 1;
      state.player.x += (dx / length) * speed * delta;
      state.player.y += (dy / length) * speed * delta;
      state.player.x = Math.max(20, Math.min(canvas.width - 20, state.player.x));
      state.player.y = Math.max(20, Math.min(canvas.height - 20, state.player.y));

      if (state.player.dashTimer > 0) {
        state.player.dashTimer -= delta;
      }
      if (state.player.dashCooldown > 0) {
        state.player.dashCooldown -= delta;
      }

      if (state.player.energy < state.player.maxEnergy) {
        state.player.energy = Math.min(state.player.maxEnergy, state.player.energy + 12 * delta);
      }
    }

    function updateBullets(delta) {
      state.bullets.forEach((bullet) => {
        bullet.x += bullet.vx * delta;
        bullet.y += bullet.vy * delta;
        bullet.life -= delta;
      });
      state.bullets = state.bullets.filter((bullet) => bullet.life > 0);
    }

    function updateEnemies(delta) {
      state.enemies.forEach((enemy) => {
        const dx = state.player.x - enemy.x;
        const dy = state.player.y - enemy.y;
        const dist = Math.hypot(dx, dy) || 1;
        enemy.x += (dx / dist) * enemy.speed * delta;
        enemy.y += (dy / dist) * enemy.speed * delta;
        if (enemy.hitTimer > 0) enemy.hitTimer -= delta;
      });
    }

    function spawnRing() {
      state.hazards.push({
        id: crypto.randomUUID(),
        type: "ring",
        radius: 0,
        speed: 220 + state.threat * 18,
        hit: false
      });
    }

    function spawnMine() {
      const margin = 80;
      const x = margin + Math.random() * (canvas.width - margin * 2);
      const y = margin + Math.random() * (canvas.height - margin * 2);
      state.hazards.push({
        id: crypto.randomUUID(),
        type: "mine",
        x,
        y,
        radius: 14,
        timer: 5 + Math.random() * 3
      });
    }

    function updateHazards(delta) {
      state.ringTimer -= delta;
      state.mineTimer -= delta;
      if (state.ringTimer <= 0) {
        spawnRing();
        state.ringTimer = Math.max(4, 10 - state.threat * 0.6);
      }
      if (state.mineTimer <= 0) {
        spawnMine();
        state.mineTimer = Math.max(3, 8 - state.threat * 0.4);
      }

      state.hazards.forEach((hazard) => {
        if (hazard.type === "ring") {
          hazard.radius += hazard.speed * delta;
          const dist = Math.hypot(state.player.x - canvas.width / 2, state.player.y - canvas.height / 2);
          if (!hazard.hit && Math.abs(dist - hazard.radius) < 10 && state.player.dashTimer <= 0) {
            if (state.shieldTimer <= 0) {
              state.player.hp -= 10;
              state.combo.count = 0;
              if (state.player.hp <= 0) endRun();
            }
            hazard.hit = true;
          }
        }
        if (hazard.type === "mine") {
          hazard.timer -= delta;
          const dist = Math.hypot(state.player.x - hazard.x, state.player.y - hazard.y);
          if (dist < 26 || hazard.timer <= 0) {
            hazard.exploded = true;
            spawnParticles(hazard.x, hazard.y, "#ff6b6b", 30);
            if (dist < 40 && state.player.dashTimer <= 0 && state.shieldTimer <= 0) {
              state.player.hp -= 14;
              state.combo.count = 0;
              if (state.player.hp <= 0) endRun();
            }
          }
        }
      });
      state.hazards = state.hazards.filter((hazard) => {
        if (hazard.type === "ring") return hazard.radius < Math.max(canvas.width, canvas.height);
        if (hazard.type === "mine") return !hazard.exploded;
        return false;
      });
    }

    function getPickupRange() {
      return state.pickupRange + (state.magnetTimer > 0 ? 80 : 0);
    }

    function updatePickups(delta) {
      const effectiveRange = getPickupRange();
      state.pickups.forEach((pickup) => {
        const dx = state.player.x - pickup.x;
        const dy = state.player.y - pickup.y;
        const dist = Math.hypot(dx, dy);
        if (dist < effectiveRange) {
          pickup.x += (dx / dist) * 120 * delta;
          pickup.y += (dy / dist) * 120 * delta;
        }
        pickup.timer -= delta;
      });
      state.pickups = state.pickups.filter((pickup) => pickup.timer > 0);
    }

    function updateParticles(delta) {
      state.particles.forEach((particle) => {
        particle.x += particle.vx * delta;
        particle.y += particle.vy * delta;
        particle.life -= delta;
      });
      state.particles = state.particles.filter((particle) => particle.life > 0);
    }

    function handleCollisions() {
      state.bullets.forEach((bullet) => {
        state.enemies.forEach((enemy) => {
          if (enemy.hp <= 0) return;
          const dist = Math.hypot(enemy.x - bullet.x, enemy.y - bullet.y);
          if (dist < 18) {
            enemy.hp -= 18;
            enemy.hitTimer = 0.2;
            bullet.pierce -= 1;
            if (bullet.pierce < 0) bullet.life = 0;
            if (state.chain > 0) {
              const target = state.enemies
                .filter((other) => other !== enemy && other.hp > 0)
                .sort((a, b) => Math.hypot(a.x - enemy.x, a.y - enemy.y) - Math.hypot(b.x - enemy.x, b.y - enemy.y))[0];
              if (target && Math.hypot(target.x - enemy.x, target.y - enemy.y) < 140) {
                target.hp -= 10 * state.chain;
              }
            }
            state.combo.timer = 3;
          }
        });
      });

      state.enemies.forEach((enemy) => {
        if (enemy.hp <= 0) return;
        const dist = Math.hypot(enemy.x - state.player.x, enemy.y - state.player.y);
        if (dist < state.player.radius + 12 && state.player.dashTimer <= 0) {
          if (state.shieldTimer > 0) {
            enemy.hp -= 12;
            enemy.hitTimer = 0.2;
            return;
          }
          state.player.hp -= enemy.boss ? 22 : 12;
          enemy.hp -= 10;
          enemy.hitTimer = 0.3;
          state.combo.count = 0;
          if (state.player.hp <= 0) {
            endRun();
          }
        }
      });

      state.pickups.forEach((pickup) => {
        const dist = Math.hypot(pickup.x - state.player.x, pickup.y - state.player.y);
        if (dist < 18) {
          if (pickup.type === "chip") {
            state.chips += pickup.value;
            localStorage.setItem("neon-loop-chips", state.chips);
          } else if (pickup.type === "overdrive") {
            state.overdriveTimer = 6;
            showToast("Overdrive online!");
          } else if (pickup.type === "shield") {
            state.shieldTimer = 6;
            showToast("Shield core active!");
          } else if (pickup.type === "magnet") {
            state.magnetTimer = 8;
            showToast("Magnet field engaged!");
          }
          state.score += pickup.value * 4;
          pickup.timer = 0;
        }
      });
    }

    function getEffectiveFireRate() {
      const bonus = state.overdriveTimer > 0 ? 1.8 : 1;
      return state.fireRate * bonus;
    }

    function updateBuffTimers(delta) {
      if (state.overdriveTimer > 0) state.overdriveTimer = Math.max(0, state.overdriveTimer - delta);
      if (state.shieldTimer > 0) state.shieldTimer = Math.max(0, state.shieldTimer - delta);
      if (state.magnetTimer > 0) state.magnetTimer = Math.max(0, state.magnetTimer - delta);
      renderBuffs();
    }

    function handleEnemyDeaths() {
      state.enemies.forEach((enemy) => {
        if (enemy.hp <= 0 && !enemy.dead) {
          enemy.dead = true;
          state.score += enemy.type.score * (1 + state.combo.count * 0.1);
          state.combo.count += 1;
          spawnParticles(enemy.x, enemy.y, enemy.type.color, enemy.boss ? 40 : 18);
          if (Math.random() < 0.35) {
            spawnPickup(enemy.x, enemy.y, enemy.boss ? 12 : 5, "chip");
          }
          if (Math.random() < 0.16) {
            spawnBuffPickup(enemy.x, enemy.y);
          }
          if (enemy.boss) {
            spawnPickup(enemy.x, enemy.y, 18, "chip");
          }
        }
      });
      state.enemies = state.enemies.filter((enemy) => enemy.hp > 0);
    }

    function updateCombo(delta) {
      if (state.combo.timer > 0) {
        state.combo.timer -= delta;
        if (state.combo.timer <= 0) {
          state.combo.count = 0;
        }
      }
    }

    function updateSpawns(delta) {
      state.spawnTimer -= delta;
      if (state.spawnTimer <= 0) {
        spawnEnemy();
        state.spawnTimer = Math.max(0.3, 1.2 - state.difficulty * 0.08);
      }
    }

    function updateLoop(delta) {
      state.loopTimer += delta;
      if (state.loopTimer > 30) {
        state.loopTimer = 0;
        state.loop += 1;
        state.difficulty += 0.4;
        state.threat = 1 + state.loop * 0.4 + state.difficulty * 0.2;
        state.player.hp = Math.min(state.player.maxHp, state.player.hp + state.loopRegen);
        spawnCardOptions();
        if (state.loop % 3 === 0) {
          spawnBoss();
        }
      }
    }

    function endRun() {
      state.running = false;
      state.best = Math.max(state.best, Math.floor(state.score));
      localStorage.setItem("neon-loop-best", state.best);
      showToast("Run over. Click Start Run to loop again.");
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "rgba(8, 12, 22, 0.8)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = "rgba(109,243,255,0.1)";
      for (let i = 0; i < canvas.width; i += 60) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i, canvas.height);
        ctx.stroke();
      }
      for (let i = 0; i < canvas.height; i += 60) {
        ctx.beginPath();
        ctx.moveTo(0, i);
        ctx.lineTo(canvas.width, i);
        ctx.stroke();
      }

      state.pickups.forEach((pickup) => {
        if (pickup.type === "chip") {
          ctx.fillStyle = "#f7c96b";
        } else if (pickup.type === "overdrive") {
          ctx.fillStyle = "#6df3ff";
        } else if (pickup.type === "shield") {
          ctx.fillStyle = "#8b8bff";
        } else if (pickup.type === "magnet") {
          ctx.fillStyle = "#ff7ad9";
        } else {
          ctx.fillStyle = "#f7c96b";
        }
        ctx.beginPath();
        ctx.arc(pickup.x, pickup.y, 6, 0, Math.PI * 2);
        ctx.fill();
      });

      state.hazards.forEach((hazard) => {
        if (hazard.type === "ring") {
          ctx.strokeStyle = "rgba(255, 107, 107, 0.5)";
          ctx.beginPath();
          ctx.arc(canvas.width / 2, canvas.height / 2, hazard.radius, 0, Math.PI * 2);
          ctx.stroke();
        }
        if (hazard.type === "mine") {
          ctx.fillStyle = "#ff6b6b";
          ctx.beginPath();
          ctx.arc(hazard.x, hazard.y, hazard.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "rgba(255,255,255,0.3)";
          ctx.stroke();
        }
      });

      state.particles.forEach((particle) => {
        ctx.fillStyle = particle.color;
        ctx.globalAlpha = Math.max(particle.life, 0);
        ctx.fillRect(particle.x, particle.y, 3, 3);
        ctx.globalAlpha = 1;
      });

      state.bullets.forEach((bullet) => {
        ctx.fillStyle = "#6df3ff";
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
        ctx.fill();
      });

      state.enemies.forEach((enemy) => {
        ctx.fillStyle = enemy.type.color;
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y, enemy.boss ? 18 : 12, 0, Math.PI * 2);
        ctx.fill();
        if (enemy.hitTimer > 0) {
          ctx.strokeStyle = "#ffffff";
          ctx.stroke();
        }
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillRect(enemy.x - 18, enemy.y - 22, 36, 4);
        ctx.fillStyle = enemy.type.color;
        ctx.fillRect(enemy.x - 18, enemy.y - 22, 36 * (enemy.hp / enemy.maxHp), 4);
      });

      ctx.fillStyle = "#6df3ff";
      ctx.beginPath();
      ctx.arc(state.player.x, state.player.y, state.player.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#ffffff";
      ctx.stroke();

      ctx.strokeStyle = "rgba(109,243,255,0.25)";
      ctx.beginPath();
      ctx.arc(state.player.x, state.player.y, getPickupRange(), 0, Math.PI * 2);
      ctx.stroke();
    }

    function loop(timestamp) {
      if (!state.lastTime) state.lastTime = timestamp;
      const delta = ((timestamp - state.lastTime) / 1000) * state.speed;
      state.lastTime = timestamp;
      if (state.running) {
        if (state.mouse.down) {
          state.fireTimer -= delta;
          if (state.fireTimer <= 0) {
            shoot();
            state.fireTimer = 1 / getEffectiveFireRate();
          }
        }
        updatePlayer(delta);
        updateBullets(delta);
        updateEnemies(delta);
        updatePickups(delta);
        updateParticles(delta);
        updateHazards(delta);
        updateBuffTimers(delta);
        handleCollisions();
        handleEnemyDeaths();
        updateCombo(delta);
        updateSpawns(delta);
        updateLoop(delta);
      }
      render();
      updateUI();
      requestAnimationFrame(loop);
    }

    canvas.addEventListener("mousemove", (event) => {
      const rect = canvas.getBoundingClientRect();
      state.mouse.x = ((event.clientX - rect.left) / rect.width) * canvas.width;
      state.mouse.y = ((event.clientY - rect.top) / rect.height) * canvas.height;
    });

    canvas.addEventListener("mousedown", () => {
      state.mouse.down = true;
    });

    canvas.addEventListener("mouseup", () => {
      state.mouse.down = false;
    });

    document.addEventListener("keydown", (event) => {
      state.keys[event.key] = true;
      if (event.key === "Shift" && state.player.dashCooldown <= 0) {
        state.player.dashTimer = 0.25;
        state.player.dashCooldown = state.player.dashCooldownMax || 0.8;
      }
      if (event.key === " ") {
        shoot();
      }
      if (event.key.toLowerCase() === "e") {
        castBurst();
      }
    });

    document.addEventListener("keyup", (event) => {
      state.keys[event.key] = false;
    });

    ui.startRun.addEventListener("click", () => {
      resetRun();
      state.running = true;
    });

    ui.pause.addEventListener("click", () => {
      state.running = !state.running;
      ui.pause.textContent = state.running ? "Pause" : "Resume";
    });

    ui.speed.addEventListener("click", () => {
      state.speed = state.speed === 1 ? 1.6 : 1;
      ui.speed.textContent = state.speed === 1 ? "Speed x1" : "Speed x1.6";
    });

    ui.burst.addEventListener("click", castBurst);

    renderTips();
    renderBuffs();
    updateUI();
    updateMetaButtons();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
